<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Redis学习 |  Charles
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon2.ico" />
  
  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/pace.min.js"></script>

  

  

<link rel="alternate" href="/atom.xml" title="Charles" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-Redis学习" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Redis学习
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/19/Redis学习/" class="article-date">
  <time datetime="2020-04-19T04:28:58.514Z" itemprop="datePublished">2020-04-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.6k字</span>
        </span>
    </span>


    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">25分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="1-NoSQL数据库概述"><a href="#1-NoSQL数据库概述" class="headerlink" title="1. NoSQL数据库概述"></a>1. NoSQL数据库概述</h2><p>NoSQL（NoSQL=Not Only SQL），意即“不仅仅是SQL”，泛指非关系型的数据库。</p>
<ul>
<li>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</li>
<li>不遵循SQL标准。</li>
<li>不支持ACID。</li>
<li>远超于SQL的性能。</li>
</ul>
<p>NoSQL适用场景</p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<p>NoSQL不适用场景</p>
<ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储，处理复杂的关系，需要即席查询(条件查询)。</li>
</ul>
<p>用不着sql和用了sql也不行的情况，请考虑用NoSql。</p>
<h2 id="2-缓存数据库"><a href="#2-缓存数据库" class="headerlink" title="2. 缓存数据库"></a>2. 缓存数据库</h2><p>Memcached（很早出现的NoSql数据库）</p>
<ul>
<li>优点：<ul>
<li>支持简单的key-value模式</li>
<li>内存使用率较高</li>
<li>支持多核多线程</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法容灾</li>
<li>数据都在内存中，不支持持久化</li>
</ul>
</li>
</ul>
<p>Redis</p>
<ul>
<li>优点：<ul>
<li>几乎覆盖了Memcached的绝大部分功能</li>
<li>数据都在内存中，支持持久化（RDB，AOF），可用作备份恢复</li>
<li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等</li>
</ul>
</li>
<li>缺点：<ul>
<li>单线程（不建议进行大数据量存储）</li>
<li>单核（无法充分利用cpu多核性能，建议使用多实例）</li>
</ul>
</li>
</ul>
<p>Ehcache</p>
<ul>
<li>优点：<ul>
<li>基于java开发，被apache认证的</li>
<li>基于jvm缓存，简单，轻巧，方便（广泛应用于hibernate，Mybatis）</li>
</ul>
</li>
<li>缺点：<ul>
<li>不支持集群，单点。</li>
<li>不支持分布式，存储容量不支持扩展。</li>
</ul>
</li>
</ul>
<p>mongoDB</p>
<ul>
<li>高性能、开源、模式自由（schema free）的文档型数据库</li>
<li>数据都在内存中，如果内存不足，支持先进先出</li>
<li>虽然是key-value模式，但是对value（尤其是json）提供把不常用的数据保存到硬盘的丰富的查询功能</li>
<li>支持二进制数据及大型对象（可以存图片）</li>
<li>可以根据数据的特点替代RDBMS，成为独立的数据库。或者配合RDBMS，</li>
</ul>
<p>HBase</p>
<ul>
<li>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</li>
<li>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</li>
</ul>
<p>Apache CASSANDRA</p>
<ul>
<li>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集（数据量通常达到PB级别）。</li>
<li>在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</li>
</ul>
<p>Neo4j</p>
<ul>
<li>主要用于描述社会关系,公共交通网络,地图及网络图谱。</li>
</ul>
<h2 id="3-Redis基础"><a href="#3-Redis基础" class="headerlink" title="3. Redis基础"></a>3. Redis基础</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​    Redis是一个开源的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string（字符串）、list（链表）、set（集合）、zset（sorted set–有序集合）和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ol>
<li><p>配合关系型数据库做高速缓存</p>
<ul>
<li>高频次，热门访问的数据，降低数据库IO</li>
<li>分布式架构，做session共享</li>
</ul>
</li>
<li><p>由于其拥有持久化能力，利用其多样的数据结构存储特定的数据。</p>
<ul>
<li>最新N个数据——通过List实现按自然时间排序的数据</li>
<li>排行榜、TopN——利用zset（有序集合）</li>
<li>时效性的数据，比如手机验证码——设置Expire过期</li>
<li>计数器，秒杀——原子性，自增方法INCR、DECR</li>
<li>去除大量数据中的重复数据——利用Set集合</li>
<li>构建队列——利用list集合</li>
<li>发布订阅消息系统——pub/sub模式</li>
</ul>
</li>
</ol>
<h3 id="3-安装启动"><a href="#3-安装启动" class="headerlink" title="3. 安装启动"></a>3. 安装启动</h3><p>可以先备份一份redis.conf(linux下默认在/opt/redis-&lt;版本号&gt;文件夹下)，然后修改自己想要的配置。</p>
<p>例如修改redis.conf文件夹里的daemonize no改成daemonize  yes，改成了后台启动</p>
<pre class=" language-bash"><code class="language-bash">redis-server  /myredis/redis.conf  //使用/myredis/redis.conf的配置文件启动服务器，默认配置启动后面可不加文件路径
<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> redis    //linux指令，查看进程运行状况，包含ip和端口信息
<span class="token function">kill</span> 进程编号        //linux指令，杀掉进程
redis-cli -h 127.0.0.1 -p 6379  //客户端连接服务器，连接ip为127.0.0.1，端口为6379，默认情况可直接redis-cli连接
redis-cli -p 6397 <span class="token function">shutdown</span>  //关闭端口为6397的服务器<span class="token punctuation">(</span>会连带客户端一起关掉<span class="token punctuation">)</span>,默认端口-p 6397可不加
//进入客户端之后的一些redis命令
<span class="token function">ping</span>    //测试连接状况，返回PONG，则连接正常
<span class="token keyword">exit</span>    //退出客户端
<span class="token function">shutdown</span>    //关闭服务器（会连带客户端一起关掉）</code></pre>
<p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库</p>
<ul>
<li>使用select <dbid> 来切换数据库</dbid></li>
</ul>
<p><strong>Redis是单线程+多路IO复用技术</strong></p>
<p>​    多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<p>​    串行 vs 多线程+锁（memcached）vs 单线程+多路IO复用（Redis）</p>
<h3 id="4-数据操作"><a href="#4-数据操作" class="headerlink" title="4. 数据操作"></a>4. 数据操作</h3><h4 id="1-key"><a href="#1-key" class="headerlink" title="1. key"></a>1. key</h4><pre class=" language-bash"><code class="language-bash">keys *             //查询当前库的所有键
exists <span class="token operator">&lt;</span>key<span class="token operator">></span>    //判断某个键是否存在
<span class="token function">type</span> <span class="token operator">&lt;</span>key<span class="token operator">></span>        //查看键的类型
del <span class="token operator">&lt;</span>key<span class="token operator">></span>        //删除某个键
expire <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>seconds<span class="token operator">></span>    //为键值设置过期时间，单位为秒
ttl <span class="token operator">&lt;</span>key<span class="token operator">></span>        //查看键值还有多少秒过期，-1代表永不过期，-2代表已经过期
dbsize            //查看
Flushdb            //清空当前库
Flushall        //清空所有库</code></pre>
<h4 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h4><ul>
<li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>String类型是二进制安全的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化的对象。</li>
<li>一个Redis中字符串value最多可以是512M。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">get <span class="token operator">&lt;</span>key<span class="token operator">></span>            //查询对应键值的value
<span class="token keyword">set</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>    //添加键值对
append <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>//将给定的value添加到原值的末尾
strlen <span class="token operator">&lt;</span>key<span class="token operator">></span>         //获得值的长度
setnx <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>    //只有在key不存在时设置key值
incr <span class="token operator">&lt;</span>key<span class="token operator">></span>            //将key对应的数字值+1，只能对数字值操作，如果为空，新增值为1
decr <span class="token operator">&lt;</span>key<span class="token operator">></span>             //将key对应的数字值-1，只能x对数字值操作，如果为空，新增值为-1
incrby/decrby <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>x<span class="token operator">></span>    //将key对应的数字值增或减x
mset <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span><span class="token punctuation">..</span>.//同时设置1个或多个key-value对
mget <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span><span class="token punctuation">..</span>.//同时获取1个或多个value
msetnx <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span><span class="token punctuation">..</span>//同时设置1个或多个key-value对,当且仅当所有key都不存在时设置成功
getrange <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>起始位置<span class="token operator">></span> <span class="token operator">&lt;</span>结束位置<span class="token operator">></span> //获得值的范围，类似Java中的substring
setrange <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>起始位置<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span> //用<span class="token operator">&lt;</span>value<span class="token operator">></span> 覆写<span class="token operator">&lt;</span>key<span class="token operator">></span>所存储的字符串值，从<span class="token operator">&lt;</span>起始位置<span class="token operator">></span>开始
setex <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>过期时间<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span> //设置键值的同时，设置过期时间，单位秒
getset <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>  //以新换旧，设置新值的同时获得旧值</code></pre>
<p><strong>原子性</strong></p>
<p>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到另一个线程）。</p>
<ol>
<li>在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li>
<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>
</ol>
<p><strong>Redis单命令的原子性主要得益于Redis的单线程。</strong></p>
<h4 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h4><p>单键多值</p>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或尾部。</p>
<p>它的底层实际上是一个双向链表，对两端的操作性能很高。通过索引下标的操作中间的节点性能会较差。</p>
<pre class=" language-bash"><code class="language-bash">lpush/rpush <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span> //从左边或右边插入一个或多个值
lpop/rpop <span class="token operator">&lt;</span>key<span class="token operator">></span>                      //从左边或右边弹出一个值，值在键在，值光键亡
rpoplpush <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span>                //从<span class="token operator">&lt;</span>key1<span class="token operator">></span>列表右边突出一个值，插到<span class="token operator">&lt;</span>key2<span class="token operator">></span>列表左边
lrange <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>start<span class="token operator">></span> <span class="token operator">&lt;</span>stop<span class="token operator">></span>            //按照索引下标获得元素<span class="token punctuation">(</span>从左到右<span class="token punctuation">)</span>，lrange <span class="token operator">&lt;</span>key<span class="token operator">></span> 0 -1 获取从头到尾全部元素
lindex <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>index<span class="token operator">></span>                //按照索引下标获得单个元素
llen <span class="token operator">&lt;</span>key<span class="token operator">></span>                            //获得列表的长度
linsert <span class="token operator">&lt;</span>key<span class="token operator">></span> before/after <span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token operator">&lt;</span>newvalue<span class="token operator">></span> //在<span class="token operator">&lt;</span>value<span class="token operator">></span>的前/后面插入<span class="token operator">&lt;</span>newvalue<span class="token operator">></span>
lrem <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>n<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>                //从左到右删除n个值为value的值</code></pre>
<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h4><p>​    Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>​    Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p>
<pre class=" language-bash"><code class="language-bash">sadd <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span><span class="token punctuation">..</span>. //将一个或多个元素加入到集合key
smembers <span class="token operator">&lt;</span>key<span class="token operator">></span>                    //取出该集合所有的值
sismember <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>            //判断集合<span class="token operator">&lt;</span>key<span class="token operator">></span>是否包含<span class="token operator">&lt;</span>value<span class="token operator">></span>的值，有则返回1，无则返回0
scard <span class="token operator">&lt;</span>key<span class="token operator">></span>                        //返回该集合的元素个数
srem <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span><span class="token punctuation">..</span>.    //删除集合中的某些元素
spop <span class="token operator">&lt;</span>key<span class="token operator">></span>                         //随机从该集合中弹出一个值
srandmember <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>n<span class="token operator">></span>            //随即从该集合中获取n个值，但不会从集合中删除这些值
sinter <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span>            //返回两个集合的交集元素
sunion <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span>            //返回两个集合的并集元素
<span class="token function">sdiff</span> <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span>                //返回两个集合的差集元素</code></pre>
<h4 id="5-Hash"><a href="#5-Hash" class="headerlink" title="5. Hash"></a>5. Hash</h4><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,String&gt;</p>
<pre class=" language-bash"><code class="language-bash">hset <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>field<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>        //给<span class="token operator">&lt;</span>key<span class="token operator">></span>集合中的<span class="token operator">&lt;</span>feild<span class="token operator">></span>键赋值<span class="token operator">&lt;</span>value<span class="token operator">></span>
hget <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>field<span class="token operator">></span>                //从<span class="token operator">&lt;</span>key1<span class="token operator">></span>集合<span class="token operator">&lt;</span>field<span class="token operator">></span>取出value
hmset <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>field1<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>field2<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span> //批量赋值
hexists <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>field<span class="token operator">></span>            //查看哈希表key中给定field是否存在
hkeys <span class="token operator">&lt;</span>key<span class="token operator">></span>                        //列出该hash集合的所有field
hvals <span class="token operator">&lt;</span>key<span class="token operator">></span>                        //列出该hash集合的所有value
hincrby <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>field<span class="token operator">></span> <span class="token operator">&lt;</span>increment<span class="token operator">></span> //为hash表key中的域field的值加上增量increment
hsetnx <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>field<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>    //将hash表key中的域field的值设为value，当且仅当field不存在时。
hgetall key                        //获取该hash表中所有的field和value</code></pre>
<h4 id="6-zset（sorted-set）"><a href="#6-zset（sorted-set）" class="headerlink" title="6. zset（sorted set）"></a>6. zset（sorted set）</h4><p>​    Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>​    不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。</p>
<p>​    因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<pre class=" language-bash"><code class="language-bash">//将一个或多个members及其score值加入有序集key中，如果先后添加分数不同的相同元素，会更新分数
zadd <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>score1<span class="token operator">></span> <span class="token operator">&lt;</span>value1<span class="token operator">></span> <span class="token operator">&lt;</span>score2<span class="token operator">></span> <span class="token operator">&lt;</span>value2<span class="token operator">></span><span class="token punctuation">..</span>.
//返回有序集key中，下标在start和stop之间的元素，带withscores，可以让分数和值一起返回到结果集
zrange <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>start<span class="token operator">></span> <span class="token operator">&lt;</span>stop<span class="token operator">></span> <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span>
//返回有序集key中，所有score值介于min和max之间<span class="token punctuation">(</span>包括等于min或max<span class="token punctuation">)</span>的成员。有序集成员按照score值递增排列
zrangebyscore <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>min<span class="token operator">></span> <span class="token operator">&lt;</span>max<span class="token operator">></span> <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
//同上，有序集成员按照score值递减排列
zrevrangebyscore <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>max<span class="token operator">></span> <span class="token operator">&lt;</span>min<span class="token operator">></span> <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count<span class="token punctuation">]</span>
zincrby <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>increment<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>    //为元素的score加上增量
zrem <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>                    //删除该集合下指定的元素
zcount <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>min<span class="token operator">></span> <span class="token operator">&lt;</span>max<span class="token operator">></span>            //统计该集合分数区间的元素个数
zrank <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>                    //返回该值在集合中的排名，从0开始</code></pre>
<h3 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h3><ol>
<li><p>可以在默认配置文件中包含其他配置文件</p>
<pre class=" language-bash"><code class="language-bash">include /path/redisconf1.conf
include /path/redisconf1.conf</code></pre>
</li>
<li><p>ip地址绑定</p>
<p>默认情况下</p>
<pre class=" language-bash"><code class="language-bash">//只能接受本机访问，不写可接受任何ip地址访问
bind<span class="token operator">=</span>127.0.0.1
//如果开启了protcted-mode，那么在没有设定bind ip且没有设置密码的情况下，redis只允许本机访问
protected-mode no    </code></pre>
</li>
<li><p>tcp-backlog</p>
<pre class=" language-bash"><code class="language-bash">tcp-backlog 511</code></pre>
<p>可以理解是一个请求到达后至到接受进程处理前所允许的最大请求个数的队列。</p>
<p>backlog队列总和=未完成三次握手队列+已经完成三次握手队列。</p>
<p>高并发环境tcp-backlog设置值由超时时限内的Redis吞吐量决定。</p>
</li>
<li><p>timeout</p>
<p>一个空闲的客户端维持多少秒会关闭，0为永不关闭。</p>
</li>
<li><p>TCP keepalive</p>
<p>对访问客户端的一种心跳检测，每个n秒检测一次。官方推荐设置为60秒。</p>
</li>
<li><p>daemonize</p>
<p>是否为后台进程</p>
</li>
<li><p>pidfile</p>
<p>存放pid文件的位置，每个实例都会产生一个不同的pid文件</p>
</li>
<li><p>loglevel</p>
<p>debug/verbose/notice/warning    四个级别</p>
<pre class=" language-bash"><code class="language-bash">loglevel noice    //生产环境设为notice或warning级别</code></pre>
</li>
<li><p>logfile</p>
<p>日志文件名称</p>
</li>
<li><p>syslog</p>
<p>是否将redis日志输送到Linux系统日志服务中</p>
</li>
<li><p>syslog-ident</p>
<p>日志的标志</p>
</li>
<li><p>syslog-facility</p>
<p>输出日志的设备</p>
</li>
<li><p>database</p>
<p>设定库的数量，默认为16</p>
</li>
<li><p>requirepass </p>
<p>设置密码，也可以在命令行中设置临时密码</p>
<pre class=" language-bash"><code class="language-bash">//临时密码
config get requirepass            //获得密码
config <span class="token keyword">set</span> requirepass <span class="token string">"123456"</span>    //设置密码
auth 123456                      //登录</code></pre>
</li>
<li><p>maxclient</p>
<p>最大客户端连接数</p>
</li>
<li><p>maxmemory</p>
<p>设置redis可以使用的内存量，一旦达到内存上限，redis将会试图移除内部数据。</p>
<p>移除规则可以通过maxmemory-policy来指定。如果Redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么Redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
</li>
<li><p>maxmemory-policy</p>
<ol>
<li>volatile-lru：使用LRU（最近最少使用）算法移除key，只对设置了过期时间的键。</li>
<li>allkeys-Iru：使用LRU算法移除key，对所有键。</li>
<li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。</li>
<li>allkeys-random：移除随机的key。</li>
<li>volatile-ttl（即将过期）：移除那些TTL值最小的key，即那些最近要过期的key。</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息。</li>
</ol>
</li>
<li><p>maxmemory-sample</p>
<p>设置样本数量，lru算法和最小ttl算法都并非是精确的算法，而是估算值，所以可以设置样本大小。</p>
<p>一般设置3-7的数字，数值越小样本越不精确，但性能消耗越小。</p>
</li>
</ol>
<h3 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h3><pre class=" language-java"><code class="language-java">Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"192.168.1.104"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="4-Redis事务"><a href="#4-Redis事务" class="headerlink" title="4. Redis事务"></a>4. Redis事务</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>​    Redis事务是一个单独的隔离操作：事务中所有的命令都会序列化、按顺序的执行。事务在执行的过程中不会被其他客户端发送来的命令请求打断。</p>
<p>​    Redis事务的主要作用就是串联多个命令防止别的命令插队。    </p>
<p>​    Redis事务更像是一个批量执行指令。</p>
<pre class=" language-bash"><code class="language-bash">multi    //开启事务
<span class="token function">exec</span>    //执行事务
discard    //撤销事务
<span class="token function">watch</span> key<span class="token punctuation">..</span> //监视一个或多个key
unwatch        //取消对所有key的监视</code></pre>
<ul>
<li>从输入muti命令开始，输入的命令都会依次进入命令队列中，但不会执行；</li>
<li>直至到输入exec后，Redis会将之前的命令队列中的命令依次执行；</li>
<li>组队的过程中可以通过discard来放弃组队。</li>
</ul>
<h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><p>​    正常执行</p>
<p>​    放弃事务</p>
<p>​    全体连坐</p>
<p>​    冤头债主</p>
<ul>
<li>组队中某个命令出现了报告错误(比如语法错误)，执行时整个的所有队列都会被撤销。</li>
<li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，其他命令都会被执行，不会回滚。</li>
</ul>
<h3 id="3-事务实现"><a href="#3-事务实现" class="headerlink" title="3. 事务实现"></a>3. 事务实现</h3><p>悲观锁（Pessimistic Lock）</p>
<ul>
<li>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
</ul>
<p><strong>乐观锁（OptimisticLock）</strong></p>
<ul>
<li>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</li>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量。</li>
<li>Redis就是利用这种check-and-set机制实现事务的。</li>
</ul>
<h3 id="4-watch"><a href="#4-watch" class="headerlink" title="4. watch"></a>4. watch</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">watch</span> <span class="token operator">&lt;</span>key1<span class="token operator">></span> <span class="token operator">&lt;</span>key2<span class="token operator">></span><span class="token punctuation">..</span>.</code></pre>
<p>​    在执行multi之前，先执行watch key，监视一个或多个key，如果在事务执行之前这些key被其他命令所改动，那么事务将被打断。</p>
<pre class=" language-bash"><code class="language-bash">unwatch</code></pre>
<p>​    取消watch命令对所有key的监视。</p>
<p>​    如果在执行watch命令之后，exec命令或discard命令先被执行了的话，就不需要执行unwatch了。</p>
<h3 id="5-三大特性"><a href="#5-三大特性" class="headerlink" title="5. 三大特性"></a>5. 三大特性</h3><ol>
<li><p>单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>没有隔离级别的概念</p>
<p>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。</p>
</li>
<li><p>不保证原子性</p>
<p>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>
</li>
</ol>
<h2 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5. 主从复制"></a>5. 主从复制</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。</p>
<p>配置从库：进入客户端输入命令 slaveof/replicaof <master ip> <master port>  或者写入配置文件</master></master></p>
<p>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</p>
<p>info replication命令查看状态信息。</p>
<p>常用3种情况：</p>
<ol>
<li>一主多仆</li>
<li>薪火相传<ol>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的写压力。</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>
</ol>
</li>
<li>反客为主<ul>
<li>SLAVEOF no one：使当前数据库停止与其他数据库的同步，转成主数据库。</li>
</ul>
</li>
</ol>
<h3 id="2-复制原理"><a href="#2-复制原理" class="headerlink" title="2. 复制原理"></a>2. 复制原理</h3><ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，<br>在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="3-哨兵模式（sentinel）"><a href="#3-哨兵模式（sentinel）" class="headerlink" title="3. 哨兵模式（sentinel）"></a>3. 哨兵模式（sentinel）</h3><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<ol>
<li><p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>
</li>
<li><p>配置哨兵,填写内容</p>
<ul>
<li>sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1</li>
<li>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</li>
</ul>
</li>
<li><p>启动哨兵</p>
<ul>
<li>redis-sentinel /myredis/sentinel.conf </li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
</li>
<li><p>原有的master挂了，投票新选，</p>
</li>
<li><p>问题：如果之前的master重启回来，会不会双master冲突？</p>
<p>原先的master重连之后会变为slave</p>
</li>
</ol>
<p>一组sentinel能同时监控多个Master</p>
<p>建议哨兵也设置成集群方式，哨兵不用设置主从，哨兵是通过发布订阅模式进行通信的。</p>
<pre class=" language-shell"><code class="language-shell"># 先完成一个哨兵的配置，sentinel.conf
# 访问控制关闭
protected-mode no
port 26379
daemonize yes
# 哨兵监控的节点，mymaster是自己起的名字，后面的2指几个哨兵发现master宕机了才进行故障转移
# 这条在几个sentinel.conf中一样的，多个sentinel监控同一个master
# master故障后，哨兵会自动修改配置文件，监控新的master
sentinel monitor mymaster 127.0.0.1 6379 2 
# 设置访问密码
# sentinel auth-pass mymaster 123456
# 哨兵多久没能连接上master就认为master宕机，单位是毫秒
sentinel down-after-milliseconds mymaster 3000
# 新的master出现后，其他follow的slave并行同步的个数。同步过程中，redis是阻塞状态，同步越多，阻塞越多。
sentinel parallel-syncs mymaster 1</code></pre>
<p>启动哨兵</p>
<pre class=" language-shell"><code class="language-shell">redis-sentinel sentinel.conf
# 进入哨兵客户端
redis-cli -p 26379
# 查看监控的对象
sentinel master mymaster
# 查看监控master的从节点
sentinel slaves mymaster
# 查看共同监控master的哨兵队友
sentinel sentinels mymaster</code></pre>
<p>springboot 的配置</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 单机配置</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
        <span class="token key atrule">host</span><span class="token punctuation">:</span> 127.0.0.1
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
        <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
<span class="token comment" spellcheck="true"># 在springboot中配置哨兵的端口，发生master宕机，由哨兵决定访问主机的地址</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
        <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
        <span class="token key atrule">sentinel</span><span class="token punctuation">:</span>
            <span class="token key atrule">master</span><span class="token punctuation">:</span> mymaster
            <span class="token key atrule">nodes</span><span class="token punctuation">:</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">26379</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">26380</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">26381</span></code></pre>
<h2 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6. 线程模型"></a>6. 线程模型</h2><p><img src="https://i.loli.net/2020/04/19/bAaQhFjCzw6e5s4.png" alt="image-20200401102005948"></p>
<p>Redis为什么单线程效率那么高？</p>
<p>1、纯内存访问：数据存放在内存中，内存的响应事件是100nm。</p>
<p>2、非阻塞式的I/O操作：Redis采用epoll作为I/O多路复用技术的实现。</p>
<p>3、采用单线程避免了不必要的上下文切换和竞争。</p>
<h2 id="7-Redis内存管理之缓存过期机制"><a href="#7-Redis内存管理之缓存过期机制" class="headerlink" title="7. Redis内存管理之缓存过期机制"></a>7. Redis内存管理之缓存过期机制</h2><ul>
<li>主动删除<ul>
<li>默认1s巡检10定义了expire的key，如果过期就删除</li>
<li>可以设置redis.conf  hz 10</li>
</ul>
</li>
<li>惰性删除<ul>
<li>如果你在访问的时候Redis发现这个key过期了，就会返回nil并删除。</li>
<li>是调用了内部的expirelfNeeded()这个方法。</li>
</ul>
</li>
</ul>
<p>如果超时比较久，并且不超时的key比较多，redis内存满了怎么办？</p>
<p>这就是Redis内存管理</p>
<pre class=" language-shell"><code class="language-shell"># redis可写内存逻辑上是决定于主从结构中最小的二主机内存 例如：master 8g，slave 4g，可写内存为4g
maxmemory <bytes> 限定主机可写入的最大内存阈值
# 内存淘汰机制
maxmemory-policy noeviction  //默认：旧缓存永不过期，如果存满，则新的缓存无法写入
# volatile-lru -> remove the key with an expire set using an LRU algorithm
# allkeys-lru -> remove any key according to the LRU algorithm
# volatile-random -> remove a random key with an expire set
# allkeys-random -> remove a random key, any key
# volatile-ttl -> remove the key with the nearest expire time (minor TTL)
# noeviction -> don't expire at all, just return an error on write operations</code></pre>
<h2 id="8-Redis分布式集群"><a href="#8-Redis分布式集群" class="headerlink" title="8. Redis分布式集群"></a>8. Redis分布式集群</h2><p>上面我们学习的内容在所有方式下，无论是主从（HA：高可用）还是单机，其实内存大小受限于一台服务器如果这个master的内存快满了，你怎么扩展，如果扩展不了，redis何以称为分布式。</p>
<p>10个key，A，B，C三个节点，A放了2个，B放了4个，C放了4个  </p>
<p>集群的特性</p>
<ul>
<li>HA的：每个节点都是一组M/S（主/从），三组节点，至少6个Redis</li>
<li>分布式的：<ul>
<li>三个Master，三个slave</li>
<li>Redis 集群并没有使用一致性hash，而是引入了哈希槽（slot）的概念。</li>
<li>Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</li>
<li>如果集群加入新的master节点，则把现有master节点的一部分slot分配给新节点（手动）。（水平拓展）</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="为什么是16384（2-14）个？"><a href="#为什么是16384（2-14）个？" class="headerlink" title="为什么是16384（2^14）个？"></a>为什么是16384（2^14）个？</h3><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用<code>char</code>进行bitmap压缩后是2k（<code>2 * 8 * 1024 = 2K</code>），也就是说使用2k的空间创建了16k的槽数。</p>
<p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k，也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。 </p>
</blockquote>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://Charles-xcz.github.io/2020/04/19/Redis学习/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2020/04/19/JVM学习(6)——JVM参数和常见OOM异常/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JVM学习(6)——常见JVM参数和内存异常</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'FxmoY9bk2JUIzmRcLKo0Ner2-gzGzoHsz',
        app_key: 'w1oDxPXzMesUY9K25GxAsVnR',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: 'Welcome to make some comments~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        Charles
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV：<span id="busuanzi_value_page_pv"></span></i>
  <i>UV：<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/attr.png" alt="Charles"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>萨瓦迪卡~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/weixinpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>