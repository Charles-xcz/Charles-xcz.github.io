<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    进程与线程及其通信方式 |  Charles
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon2.ico" />
  
  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/pace.min.js"></script>

  

  

<link rel="alternate" href="/atom.xml" title="Charles" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-进程线程协程对比" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  进程与线程及其通信方式
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/19/进程线程协程对比/" class="article-date">
  <time datetime="2020-04-19T03:34:28.214Z" itemprop="datePublished">2020-04-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a> / <a class="article-category-link" href="/categories/java/多线程/">多线程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.4k字</span>
        </span>
    </span>


    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>进程，保存在磁盘上的程序运行以后，会在内存空间里形成一个独立的内存体。这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。<strong>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位</strong>。</p>
<p><img src="https://i.loli.net/2020/04/19/1r5xjMXQV8HzDvK.png" alt></p>
<p><img src="https://i.loli.net/2020/04/19/wktIq81XSuLEl7i.jpg" alt="132501_6PVU_1863332"></p>
<h3 id="1-2-进程的五种状态"><a href="#1-2-进程的五种状态" class="headerlink" title="1.2 进程的五种状态"></a>1.2 进程的五种状态</h3><p><strong>创建：</strong>进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态。</p>
<p><strong>就绪：</strong>进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行。</p>
<p><strong>执行：</strong>进程处于就绪状态被调度后，进程进入执行状态。</p>
<p><strong>阻塞：</strong>正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用。</p>
<p><strong>终止：</strong>进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p>
<p>如果<strong>进程运行时间片使用完也会进入就绪状态</strong>。<br>另外为用户观察需要，进程还有挂起和激活两种操作。挂起后进程处于静止状态进程不再被系统调用，对于操作是激活操作。</p>
<h3 id="1-3-进程通信"><a href="#1-3-进程通信" class="headerlink" title="1.3 进程通信"></a>1.3 进程通信</h3><h4 id="1）为什么要进程通信"><a href="#1）为什么要进程通信" class="headerlink" title="1）为什么要进程通信?"></a>1）为什么要进程通信?</h4><p>1、数据传输<br>一个进程需要将它的数据发送给另一个进程;<br>2、资源共享<br>多个进程之间共享同样的资源;<br>3、通知事件<br>一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件;<br>4、进程控制<br>有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。<br>基于以上几个原因，所以就有了进程间通信的概念，那么进程间通信的原理是什仫呢？目前有哪几种进程间通信的机制？他们是如何实现进程间通信的呢？</p>
<h4 id="2）进程间通信的原理"><a href="#2）进程间通信的原理" class="headerlink" title="2）进程间通信的原理"></a>2）进程间通信的原理</h4><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为<strong>进程间通信机制</strong>。</p>
<p><img src="https://i.loli.net/2020/04/19/FngAqNQI8HbSc6k.png" alt></p>
<h4 id="3）进程通信的几种方式"><a href="#3）进程通信的几种方式" class="headerlink" title="3）进程通信的几种方式"></a>3）进程通信的几种方式</h4><h5 id="1、管道（Pipe）"><a href="#1、管道（Pipe）" class="headerlink" title="1、管道（Pipe）"></a>1、管道（Pipe）</h5><p>管道又名匿名管道，这是一种最基本的IPC机制，由pipe函数创建：</p>
<p>调用pipe函数时在内核中开辟一块缓冲区用于通信,它有一个读端，一个写端：pipefd[0]指向管道的读端，pipefd[1]指向管道的写端。所以管道在用户程序看起来就像一个打开的文件,通过read(pipefd[0])或者write(pipefd[1])向这个文件读写数据，其实是在读写内核缓冲区。</p>
<p><strong>使用管道通信的过程：</strong></p>
<ol>
<li>父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。</li>
<li>父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出,这样就实现了进程间通信。</li>
</ol>
<p><strong>管道出现的四种特殊情况：</strong></p>
<ol>
<li><p>写端关闭，读端不关闭；</p>
<p>那么管道中剩余的数据都被读取后,再次read会返回0,就像读到文件末尾一样。</p>
</li>
<li><p>写端不关闭，但是也不写数据，读端不关闭；<br>此时管道中剩余的数据都被读取之后再次read会被阻塞，直到管道中有数据可读了才重新读取数据并返回；</p>
</li>
<li><p>读端关闭，写端不关闭；<br>此时该进程会收到信号SIGPIPE，通常会导致进程异常终止。</p>
</li>
<li><p>读端不关闭，但是也不读取数据，写端不关闭；<br>此时当写端被写满之后再次write会阻塞，直到管道中有空位置了才会写入数据并重新返回。</p>
</li>
</ol>
<p><strong>使用管道的缺点：</strong></p>
<ol>
<li>两个进程通过一个管道只能实现<strong>单向通信</strong>，如果想双向通信必须再重新创建一个管道或者使用sockpair才可以解决这类问题；</li>
<li>只能用于具有<strong>亲缘关系的进程间通信</strong>，例如父子，兄弟进程。</li>
</ol>
<h5 id="2、命名管道（FIFO）"><a href="#2、命名管道（FIFO）" class="headerlink" title="2、命名管道（FIFO）"></a>2、命名管道（FIFO）</h5><p>上一种进程间通信的方式是匿名的，所以只能用于具有亲缘关系的进程间通信，命名管道的出现正好解决了这个问题。</p>
<p>FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储文件系统中。</p>
<p>命名管道是一个设备文件，因此即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。</p>
<p><strong>命名管道的特点：</strong></p>
<ol>
<li>命名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。所以当使用命名管道的时候必须先open将其打开。</li>
<li>命名管道可以用于任何两个进程之间的通信，不管这两个进程是不是父子进程，也不管这两个进程之间有没有关系。</li>
</ol>
<h5 id="3、消息队列（Message-Queue）"><a href="#3、消息队列（Message-Queue）" class="headerlink" title="3、消息队列（Message Queue）"></a>3、消息队列（Message Queue）</h5><p>消息队列就是消息的链表，位于内核中。消息队列中每个<strong>数据块</strong>都被认为是<strong>有一个类型</strong>，接收者进程接收的数据块可以有不同的类型值。消息队列是基于消息的，管道是基于字节流的，且消息队列的读取不一定是先入先出。</p>
<p><strong>注意：</strong></p>
<p>管道的生命周期是随进程的，只要该进程消亡了该管道就会随之消失。但是消息队列却是随内核的，即使该进程消亡了该内核中的消息队列是不会主动消失的，除非使用ipcrm -q + msg_id删除该消息队列，也可以使用ipcs -q查看系统中的消息队列。</p>
<h5 id="4、信号量（Semaphore）"><a href="#4、信号量（Semaphore）" class="headerlink" title="4、信号量（Semaphore）"></a>4、信号量（Semaphore）</h5><p><strong>什么是信号量？</strong></p>
<ul>
<li>信号量的本质是一种数据操作锁，用来负责数据操作过程中的互斥，同步等功能。</li>
<li>信号量用来管理临界资源的。它本身只是一种外部资源的标识，不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。 可以这样理解，信号量就相当于是一个计数器。当有进程对它所管理的资源进行请求时，进程先要读取信号量的值：大于0，资源可以请求；等于0，资源不可以用，这时进程会进入睡眠状态直至资源可用。</li>
<li>当一个进程不再使用资源时，信号量+1(对应的操作称为V操作)，反之当有进程使用资源时，信号量-1(对应的操作为P操作)。对信号量的值操作均为原子操作。</li>
</ul>
<p><strong>为什么要使用信号量？</strong></p>
<p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。</p>
<p><strong>什么是临界区？什么是临界资源？</strong></p>
<p>临界资源：一次只允许一个进程使用的资源。<br>临界区：访问临界资源的程序代码片段。</p>
<p><strong>信号量的工作原理？</strong></p>
<ul>
<li><p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行等待操作；</p>
</li>
<li><p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1；</p>
</li>
</ul>
<p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行了。</p>
<h5 id="5、共享内存（Shared-Memory）"><a href="#5、共享内存（Shared-Memory）" class="headerlink" title="5、共享内存（Shared Memory）"></a>5、共享内存（Shared Memory）</h5><p><strong>共享内存的特点：</strong></p>
<p>共享内存是这五种进程间通信方式中效率最高的。但是因为共享内存没有提供相应的互斥机制，所以一般共享内存都和信号量配合起来使用。</p>
<p><strong>为什么共享内存的方式比其他进程间通信的方式效率高？</strong></p>
<p>消息队列，FIFO，管道的消息传递方式一般为 ：</p>
<ol>
<li>服务器获取输入的信息；</li>
<li>通过管道，消息队列等写入数据至内存中，通常需要将该数据拷贝到内核中；</li>
<li>客户从内核中将数据拷贝到自己的客户端进程中；</li>
<li>然后再从进程中拷贝到输出文件；</li>
</ol>
<p>上述过程通常要经过4次拷贝，才能完成文件的传递。<br>而共享内存只需要：</p>
<ol>
<li>输入内容到共享内存区；</li>
<li>从共享内存输出到文件。</li>
</ol>
<p>上述过程不涉及到内核的拷贝，这些进程间数据的传递就不再通过执行任何进入内核的系统调用来传递彼此的数据，节省了时间，所以共享内存是这五种进程间通信方式中效率最高的。</p>
<h5 id="6、套接字（Socket）"><a href="#6、套接字（Socket）" class="headerlink" title="6、套接字（Socket）"></a>6、套接字（Socket）</h5><p>面说到的进程间的通信，所通信的进程都是在同一台计算机上的，而使用<code>socket</code>进行通信的进程可以是同一台计算机的进程，也是可以是通过网络连接起来的不同计算机上的进程。</p>
<p>套接字的特性由3个属性确定，它们分别是：<strong>域、类型和协议</strong>。</p>
<p><strong>1、套接字的域</strong></p>
<p>  它指定套接字通信中使用的网络介质，最常见的套接字域是<code>AF_INET</code>，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用<code>socket</code>作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。另一个域<code>AF_UNIX</code>表示<code>UNIX</code>文件系统，它就是文件输入/输出，而它的地址就是文件名。</p>
<p><strong>2、套接字类型</strong></p>
<p>  因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。这里主要讲流套接字。</p>
<p>  流套接字由类型<code>SOCK_STREAM</code>指定，它们是在<code>AF_INET</code>域中通过<code>TCP/IP</code>连接实现，同时也是<code>AF_UNIX</code>中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</p>
<p>  与流套接字相对的是由类型<code>SOCK_DGRAM</code>指定的数据报套接字，它不需要建立连接和维持一个连接，它们在<code>AF_INET</code>中通常是通过<code>UDP/IP</code>协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。</p>
<p><strong>3、套接字协议</strong></p>
<p>  只要底层的传输机制允许不止一个协议来提供要求的套接字类型，我们就可以为套接字选择一个特定的协议。通常只需要使用默认值。</p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p><strong>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</strong>。</p>
<p><img src="https://i.loli.net/2020/04/19/g4w7mZkECBHu3zF.png" alt="image-20200403114437049"></p>
<h3 id="2-1线程通信"><a href="#2-1线程通信" class="headerlink" title="2.1线程通信"></a>2.1线程通信</h3><h4 id="1、共享变量方式"><a href="#1、共享变量方式" class="headerlink" title="1、共享变量方式"></a>1、共享变量方式</h4><ol>
<li><p>Synchronized、wait、notify</p>
</li>
<li><p>Lock、Condition</p>
</li>
<li><p>volatile</p>
</li>
<li><p>CountDownLatch、CyclicBarrier、Semaphore</p>
</li>
</ol>
<h4 id="2、BlockingQueue"><a href="#2、BlockingQueue" class="headerlink" title="2、BlockingQueue"></a>2、BlockingQueue</h4><p>参见《<a href="https://charles-xcz.github.io/2020/03/12/线程阻塞和阻塞队列/">线程阻塞和阻塞队列</a>》</p>
<h4 id="3、管道通信"><a href="#3、管道通信" class="headerlink" title="3、管道通信"></a>3、管道通信</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PipedDemo</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> PipedInputStream inputStream1<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> PipedOutputStream outputStream1<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> PipedInputStream inputStream2<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> PipedOutputStream outputStream2<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token function">PipedDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    inputStream1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    outputStream1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inputStream2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    outputStream2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        inputStream1<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>outputStream2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        inputStream2<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>outputStream1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/**程序退出时，需要关闭stream*/</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    inputStream1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inputStream2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    outputStream1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    outputStream2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    PipedDemo demo <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PipedDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
        PipedInputStream in <span class="token operator">=</span> demo<span class="token punctuation">.</span>inputStream2<span class="token punctuation">;</span>
        PipedOutputStream out <span class="token operator">=</span> demo<span class="token punctuation">.</span>outputStream2<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"go"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
        PipedInputStream in <span class="token operator">=</span> demo<span class="token punctuation">.</span>inputStream1<span class="token punctuation">;</span>
        PipedOutputStream out <span class="token operator">=</span> demo<span class="token punctuation">.</span>outputStream1<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"go"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>inArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="3-进程线程的区别与联系"><a href="#3-进程线程的区别与联系" class="headerlink" title="3. 进程线程的区别与联系"></a>3. 进程线程的区别与联系</h2><h3 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h3><ul>
<li><p><strong>调度：</strong>线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p>
</li>
<li><p><strong>并发性：</strong>不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p>
</li>
<li><p><strong>拥有资源：</strong>进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p>
</li>
<li><p><strong>系统开销：</strong>在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
</li>
</ul>
<h3 id="2、联系"><a href="#2、联系" class="headerlink" title="2、联系"></a>2、联系</h3><ul>
<li><strong>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</strong>；</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>处理机分给线程，即<strong>真正在处理机上运行的是线程</strong>；</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<h2 id="4-协程"><a href="#4-协程" class="headerlink" title="4. 协程"></a>4. 协程</h2><p><img src="https://i.loli.net/2020/04/19/bstV52nYXLJw3Bj.jpg" alt="img"></p>
<p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>  协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<ul>
<li><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://Charles-xcz.github.io/2020/04/19/进程线程协程对比/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程通信/">线程通信</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/04/19/JVM学习(6)——JVM参数和常见OOM异常/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JVM学习(6)——常见JVM参数和内存异常
          
        </div>
      </a>
    
    
      <a href="/2020/03/13/设计模式—代理模式/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">设计模式——代理模式</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'FxmoY9bk2JUIzmRcLKo0Ner2-gzGzoHsz',
        app_key: 'w1oDxPXzMesUY9K25GxAsVnR',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: 'Welcome to make some comments~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        Charles
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV：<span id="busuanzi_value_page_pv"></span></i>
  <i>UV：<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/attr.png" alt="Charles"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>萨瓦迪卡~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/weixinpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=29312951&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>