{"meta":{"title":"Charles","subtitle":null,"description":null,"author":"Charles","url":"http://Charles-xcz.github.io","root":"/"},"posts":[{"tags":[{"name":"算法","slug":"算法","permalink":"http://Charles-xcz.github.io/tags/算法/"},{"name":"kmp","slug":"kmp","permalink":"http://Charles-xcz.github.io/tags/kmp/"}],"title":"模式匹配—>KMP算法","date":"2020/02/29","text":"引言​ 场景：在字符串：“fffffab cfe defe” 中查找字符串 “ff”。 ​ 被查找的字符串称之为：主串或目标串T ; ​ 想要查找的字符串”ff”称之为：字串或模式串P。 ​ 朴素的模式匹配在匹配过程中需要进行回溯，因而会发生多次重复比较，匹配效率低。故而，需要对字符串查找算法进行优化。 ​ 字符串查找算法中，最著名的算法之一：KMP算 法（Knuth-Morris-Pratt) ​ 它是精确字符串匹配算法（区别于模糊匹配）。 ​ – 目标字符串中无需进行回溯。（比朴素的模式匹配算法快）​ – 模式字符串的移动方向：从目标字符串的第一个字符 开始，朝目标字符串的尾部方向移动搜索匹配子串。 KMP算法1 KMP​ 注意：为了方便，KMP算法中，数组下标一般从1开始。 ​ KMP算法的设计初衷： 希望能在匹配过程中，目标串T中的字符匹配是一直向右前进的，而不会出现向左的回溯。 下面看两个例子 例1：当模式串中无重复时 因为模式串中无重复，因为T[1]=P[1]，T[2]=P[2]，显然T[2]!=P[1]。即第二轮比较多余 同理，2，3，4，5轮的匹配都是多余的。 例2：模式串P中有重复 从图上可以看出2，3，4，5轮，目标串匹配字符i的回溯都是多余的。我们可以直接从1跳到6。 why？？为什么可以跳？怎么跳？ 注意观察模式串字符的规律：这里我们要利用模式串P自身的重复。 下面继续放一些示例： 关注： 匹配失败，是否发生在P的第一个字符处？ ​ P中是否有重复模式？ 分析总结： ​ 前两种情况容易得出： ​ 若当前轮匹配在与P[1]比较就失败，那么 下一轮应该是比较T[i+1]和P[1] ​ 若P中在当前轮成功匹配的子串的后缀与子串的前缀无重复模式，那么下一轮应该是比较T[i]和P[1] ​ 第三种情况： ​ 若P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，那么下一轮应该是比较T[i]和P[next[j]] ​ next[j]:在模式串P的下标 j 处失配后，下一轮比较的模式串P的下标，用next数组记录模式串P每个位置失配后下一轮应该比较的位置。 那么next[j] = ？ 在上图 Case1 中，P中无重复模式，下轮比较T[i]和P[1]，下轮比较的模式串下标为1，即next[j]=1; ​ Case2中，P[1]就失配，下轮比较T[i+1]和P[1]，我们用next[j]=0来表示这种情况，代表着在模式串P开头处即失配，目标串下标i向后移动一位。我们把下标为0来代表这种情况，这也是为什么KMP算法下标从1开始计算的原因。 ​ Case3和Case4: 在P[j]处失配，设存在k|1&lt;k&lt;j 使得”P[1]…..P[k-1]“=”P[j-k+1]….P[j-1]” 即模式串P的前k-1位子串与从P[j]处往前k-1位子串相同，即P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，则下轮比较从k开始，next[j]=k。 所以： 2 KMP算法思想总结 将模式串P自身的重复规律保存到next数组中 匹配过程：若某轮匹配失败，则利用next数组分 别计算下一轮匹配时目标串和模式串的开始位置若是T[i]≠P[j]导致当前轮的匹配失败，则按照下列规则 开始下一轮匹配： 若next[j] ≠ 0，则将T[i..]与P[next[j]..]匹配； 若next[j]==0，则将T[(i+1)..]与P[1..]匹配。","permalink":"http://Charles-xcz.github.io/2020/02/29/模式匹配——KMP算法/","photos":[]},{"tags":[{"name":"红黑树","slug":"红黑树","permalink":"http://Charles-xcz.github.io/tags/红黑树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://Charles-xcz.github.io/tags/数据结构/"}],"title":"什么是红黑树？","date":"2020/02/29","text":"1. 定义红黑树是满足下列条件的二叉查找树： 每个节点都带有红色或黑色。节点的颜色由以下规则确定： 根节点是黑色的。 所有叶节点都是黑色的。 在沿着从根出发的任何路径上都不允许出现两个连续的红色节点，即：“红色”结点的两个子结点都是“黑色”的。 从任一节点到其每个子孙叶子节点的所有简单路径都包含相同数目的黑色节点（简称黑色高度） 节点X的黑色高度：从节点X到其子孙叶子节点的简单路径中的黑色链的数量。 红黑树的黑色高度：根节点的黑色高度（称为：根节点的阶）红黑树的两种不同定义： 《算法导论》：叶子节点是指，扩充外部叶结点。即叶子节点为空的“黑色”节点 - 可以认为是2-3-4树的二叉树实现 《程序员实用算法》：数据只存储在叶子节点中，内部节点只用于引用； 示例: 《算法导论》中的红黑树,，黑色高度为2。 《程序员实用算法》中的红黑树，黑色高度为2。加粗为黑色结点本文基于《算法导论》的定义介绍。 2. 红黑树 与 2-3-4树红黑树，可等价转化为2-3-4树。 为了更好的理解红黑树，先看一下2-3-4树 2.1 2-3-4树介绍2-3-4树： 2-3-4树： 是二叉查找树的扩展 树中每个节点中有1个或2个或3个关键字，节点内部是有序的。 2-节点：有1个关键字，2个孩子 3-节点：有2个关键字，3个孩子 4-节点：有3个关键字，4个孩子 具有很好的平衡性：所有叶子节点的深度相同。 2-3-4树的查找插入B结点插入结点H 注意：在插入结点过程中，按照自顶向下的方式进行访问，当发现4-节点时，进行分裂。 即：插入结点时在遍历查找插入位置的路线上，凡是遇到4-结点，就对其进行分裂 现在，自顶向下构造一棵2-3-4树 2.2 二叉树来实现2-3-4树2-3-4树中有三类节点： 2-节点，3-节点和4-节点 对于3-节点和4-节点，利用红色链来绑定“内部”节点 红色链所指向的节点为红色节点（红色链下方的结点） 2-节点不变 3-节点变为用红色链连接的两个二叉树节点，指向外部孩子节点的指针为3个，数量不变。 4-节点转化为三个用红色链连接起来的二叉树节点，指向外部孩子节点的指针为4个，数量不变。 这样，2-3-4树就转化成了二叉树。但是，可以看到，2-3-4树对应的二叉树并不唯一，哪种才是等价的红黑树呢？ 2-3-4树的2-节点和4-节点变成成二叉树节点都是唯一的情况，3-节点呢？我们人为的规定，转换成左分支的情况，（左孩子节点小于父节点，二叉查找树的性质）并且在插入新节点的过程中，产生右分支的时候我们需要把它左旋成为左分支情况。这样，2-3-4树就对应成了唯一的二叉树，即红黑树。（红色链连接代表着2-3-4树节点内部的连接，红色链下方的节点表示红色节点） 那么，现在还剩下一个问题，2-3-4树插入节点过程中的4-节点分裂，对应着二叉树怎样的变化呢？ 2-3-4树中，双亲为2-节点时，4-节点的分裂： 2-3-4树4-节点分裂对应着二叉树的颜色向上翻转，当翻转后出现，右分支情况的3-节点时，旋转成左分支情况2-3-4树中，双亲为3-节点时，4-节点的分裂：在对应二叉树中，同样可以用颜色翻转和旋转等价实现。 当反转后，出现两个红色节点连续，显然不满足红黑树的定义，要进行旋转，旋转规则类似与AVL树失衡的旋转处理。 下面的两个旋转情况，和AVL树LL失衡，LR失衡旋转情况相同 3.总结：红黑树，本质上是2-3-4树两类基本操作： 颜色翻转 实质上为4-节点分裂 当某个结点的两个孩子结点都为红色时 将两个红色孩子结点和其黑色双亲结点的颜色翻转旋转 避免出现连续的两条红色链；避免出现单个的红色右链。 出现右的红色链时：对于右的红色链，进行左旋处理 有连续两个红色链时： 依据两个连续的红色链的形状，进行相应的旋转处理（类似AVL树的失衡旋转规则） 看道小试题， 从空树出发，根据待插入的关键字序列 {03,02,01,04,05,06,07,10,09,08}.构建红黑树。 仔细体会一下红黑树的构建过程。 可以画出对应2-3-4树的插入构建过程和红黑树对比加深理解。（节点依次插入，树未发生翻转变化时省略了重复画图）注意：将红色链指向(下方)的节点定义为红色节点，不要迷惑于红色节点的变化","permalink":"http://Charles-xcz.github.io/2020/02/29/聊聊红黑树/","photos":[]},{"tags":[{"name":"JVM","slug":"JVM","permalink":"http://Charles-xcz.github.io/tags/JVM/"}],"title":"JVM学习(1)——类加载、连接与初始化","date":"2020/02/29","text":"在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。这提供了更大的灵活性，增加了更多的可能性 1. Java虚拟机与程序的生命周期 如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 2. 加载​ 查找并加载类的二进制数据，就是将二进制形式的Java类型读入Java虚拟机中。 ​ 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 3. 连接​ 类被加载后，就进入连接阶段。分为验证，准备，解析三个阶段 ​ 连接就是将已经读到内存中的类的二进制数据合并到虚拟机的运行环境中去。 ​ 验证：确保被加载类的正确性 ​ 类验证的内容 类文件的结构检查 语义检查 字节码验证 二进制兼容性的验证 ​ 准备：Java虚拟机为类的静态变量分配内存，并将其初始化为默认值 ​ 解析：把类中的符号引用（间接）转换为直接引用 4. 初始化​ 为类的静态变量赋予正确的初始值 ​ 静态变量的声明语句，以及静态代码块都被看做类的初始化语句。 ​ Java虚拟机会按照初始化语句在类文件中的先后顺序依次执行它们。 ​ 类初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 假如类中存在初始化语句，那就依次执行这些初始化语句 ​ 类初始化的时机 ​ Java对类的使用方式可分为两种 主动使用 被动使用 ​ 所有的Java虚拟机实现必须要在每个类或接口被Java程序”首次主动使用“时才初始化它们 ​ 主动使用（七种，重要） 创建类的实例（new一个实例） 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.test.Test”)） 初始化该类的子类 Java虚拟机启动时被标明为启动类的类（包含main（）方法的类） JDK1.7开始提供的动态语言支持 ​ 除了上述七种情况，其他情况都认为是对类的被动使用，因此都不会导致类的初始化 ​ 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但这条规则不适用于接口。 在初始化一个类时，并不会先初始化它所实现的接口 在初始化一个接口时，并不会先初始化它的父接口 ​ 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 ​ 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使 5. 类的实例化 为新的对象分配内存 为实例变量赋默认值 为实例变量赋正确的初始值 Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为“”。针对源代码中每一个类的构造方法，Java编译器都产生一个方法。 Some Cases/** * 类的初始化 * 虚拟机参数 -XX:+&lt;option&gt; 表示开启 &lt;option&gt; 选项 * -XX:-&lt;option&gt; 表示关闭 &lt;option&gt; 选项 * -XX:&lt;option&gt;=&lt;value&gt; 表示给 &lt;option&gt; 选项赋值 * -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来 * -XX:+TraceClassUnLoading 用于追踪类的卸载信息并打印出来 * * @author charles * @date 2020/2/19 10:40 */ public class MyTest1 &#123; public static void main(String[] args) &#123; /* 对于静态字段来说,只有直接定义了该字段的类才会被初始化 str是在MyParent1中被定义,所以 MyChild1.str是对类 MyParent1 的主动使用, 所以类 MyParent1 会被初始化 */ System.out.println(MyChild1.str); /* str2 是在 MyChild1 中被定义,所以类 MyChild1 会被初始化 初始化一个类的子类时,父类也会被初始化(主动使用) */ System.out.println(MyChild1.str2); &#125; &#125; class MyParent1 &#123; public static String str = \"hello world\"; static &#123; System.out.println(\"MyParent1 static block\"); &#125; &#125; class MyChild1 extends MyParent1 &#123; public static String str2 = \"welcome\"; static &#123; System.out.println(\"MyChild1 static block\"); &#125; &#125; /** * 定义常量的类的初始化: * 常量在编译阶段会存入到调用这个常量的方法的类的常量池中, * 本质上调用类并没有直接引用到定义常量的类,因此并不会触发定义常量类的初始化 * 反编译 javap -c com.charles.jvm.classloader.MyTest2 * 助记符: * ldc:表示将int,float或是String类型的常量值从常量池中推送至栈顶 * bipush:表示将单字节(-128~127)的常量值从常量池中推送至栈顶 * sipush:表示将短整型(-32768~32767)的常量值从常量池中推送至栈顶 * iconst_i:i属于(-1~5)表示将int型的数字i从常量池中推送至栈顶 * * @author charles * @date 2020/2/19 11:21 */ public class MyTest2 &#123; public static void main(String[] args) &#123; /* 这里常量 MyParent2.STR 存放到了类 MyTest2 的常量池中, 之后 MyTest2 与 MyParent2 就没有任何关联了 甚至,我们可以将 MyParent2 的class文件删除 */ System.out.println(MyParent2.STR); &#125; &#125; class MyParent2 &#123; public static final String STR = \"hello world\"; static &#123; System.out.println(\"MyParent2 static block!\"); &#125; &#125; //反编译结果如下 D:\\Develop\\Java\\JavaProject\\JVMStudy\\build\\classes\\java\\main&gt;javap -c com.charles.jvm.classloader.MyTest2 Compiled from \"MyTest2.java\" public class com.charles.jvm.classloader.MyTest2 &#123; public com.charles.jvm.classloader.MyTest2(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello world 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return &#125; /** * 当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中 * 这时在程序运行时,会导致主动使用这个常量所在类,显然会导致这个类被初始化 * * @author charles * @date 2020/2/20 10:24 */ public class MyTest3 &#123; public static void main(String[] args) &#123; System.out.println(MyParent3.STRING); &#125; &#125; class MyParent3 &#123; public static final String STRING = UUID.randomUUID().toString(); static &#123; System.out.println(\"MyParent3 static block\"); &#125; &#125; /** * 创建类的实例,主动使用 * 对于数组实例来说,其类型是由JVM在运行期间动态生成的, * 表示为[Lcom.charles.jvm.classloader.MyParent4这种形式 * 动态生成的类型其父类就是Object * 对于数组来说,JavaDoc经常将构成数组的元素为Component,实际上就是将数组降低一个维度后的类型 * 助记符: * anewarray:表示创建一个引用类型的数组,并将其引用值压入栈顶 * newarray:表示创建一个指定的原始类型的数组,并将其引用值压入栈顶 * * @author charles * @date 2020/2/20 10:33 */ public class MyTest4 &#123; public static void main(String[] args) &#123; /* 首次主动使用才会初始化 */ MyParent4 p1 = new MyParent4(); MyParent4 p2 = new MyParent4(); /* 类的数组的实例,不是对类的主动使用 */ MyParent4[] parent4s = new MyParent4[2]; &#125; &#125; class MyParent4 &#123; static &#123; System.out.println(\"MyParent4 static block\"); &#125; &#125; /** * 当一个接口在初始化时,并不都要求其父接口完成初始化 * 只有当真正使用到父接口的时候(如引用到接中的常量时),才会初始化 * * @author charles * @date 2020/2/20 11:00 */ public class MyTest5 &#123; public static void main(String[] args) &#123; System.out.println(MyChild5.B); &#125; &#125; interface MyParent5 &#123; /** * 接口中的属性,默认为public static final */ int A = 5; &#125; interface MyChild5 extends MyParent5 &#123; int B = new Random().nextInt(); &#125; /** * @author charles * @date 2020/2/20 11:31 */ public class MyTest6 &#123; public static void main(String[] args) &#123; /* 调用了类Singleton中的静态方法,为主动使用,类Singleton被初始化 */ Singleton singleton = Singleton.getInstance(); System.out.println(\"counter1:\" + Singleton.counter1); System.out.println(\"counter2:\" + Singleton.counter2); &#125; &#125; class Singleton &#123; /** * 初始化counter1为1 */ public static int counter1 = 1; /** * 按顺序进行初始化,构造函数执行后,counter1=4,counter2=3 */ private static Singleton singleton = new Singleton(); /** * 然后counter2又被赋值为0 */ public static int counter2 = 8; private Singleton() &#123; /* counter1在前面已经被初始化为1,所以counter1=1+3 */ counter1 += 3; /* 准备阶段的意义 因为准备阶段,整型的默认值为0 所以counter2=0+3 */ counter2 += 3; &#125; public static Singleton getInstance() &#123; return singleton; &#125; &#125;","permalink":"http://Charles-xcz.github.io/2020/02/29/JVM学习(1)——类加载、连接与初始化/","photos":[]},{"tags":[{"name":"网络","slug":"网络","permalink":"http://Charles-xcz.github.io/tags/网络/"}],"title":"距离向量路由选择","date":"2019/11/06","text":"​ 距离向量路由选择是通过对Bellman-Ford算法进行适当修改，找到任意两结点之间的最短路径。 ​ 先介绍一下Bellman-Ford算法： 1 Bellman-Ford算法​ 这个算法基于这样一个事实，如果结点 i 的所有邻站都知道到结点的最短距离，那么求结点 i 和结点 j 之间的最短距离就可以用结点 i 到每个邻站之间的距离分别加上该邻站到结点j的最短距离，然后再从得数中选择最小的一个。 用以下步骤为每个结点创建一个最短距离表 : 1) 结点和它自己之间的最短距离和代价被初始化为0。 2) 一个结点和任何其他结点之间的最短距离被设置为无穷大。一个结点和其他任何结点之间的代价应当给定(如果两个节点之间没有直接连接，可设置为无穷大)。 3) 然后循环执行 算法Dij = min{(ci1+D1j),(ci2+D2j),……..(ciN+DNj)} 2 距离向量路由选择算法1) 在距离向量路由选择中，代价通常就是跳数（即在到达终点之前通过了多少个网络）。因此任意两个邻站之间的代价被设置为1。 2) 每当路由器从它的邻站那里接收到一些信息时，它就要异步地更新自己的路由表。换言之，每个路由器只执行了整个Bellman-Ford算法中的一部分。这个处理过程是分布式的。 3) 在路由器更新了自己的路由表之后，应当将结果发送给它的所有邻站，以便这些邻站也能更新它们的路由表。 4) 每个路由器至少应当保存每条路由的三个信息：目的网络、代价和下一跳。我们称完整的路由表为Table，表中的第i行为Tablei第i行的三个列分别为Tablei.dest，Tablei.cost和Tablei.next。 5) 我们把来自邻站的一条路由信息称为一个R（记录），它只包含了两个信息：R.dest和R.cost。在收到的记录中不包含下一跳信息，因为下一跳就是发送方的源地址。 3 计数到无穷大​ 距离向量路由的缺点是：好消息传得快，坏消息传得慢。要想让路由选择协议能够正常工作，如果一条链路中断了（代价变为无穷大），那么其他所有路由器都应当立刻获知这一情况，但是在距离向量路由选择中，这是要花费一些时间的。这个问题就称为计数到无穷大（count to infinity）。需要经过多次更新才能使所有的路由器都把这条中断链路的代价记录为无穷大。 二结点循环问题: 为了解决这种不稳定性的几种方法： 1) 定义无穷大：距离向量协议一般把16定义为无穷大，即16跳为不可达，但是这也意味着距离向量不能用于大系统。在各个方向上，网络的大小都不能超过15跳。 2) 分割范围：如果结点B根据其路由表认为到达X的最佳路由要经过A，那么它就不需要再把到X的路由通告给A了，因为这个信息就是从A来的（A已经知道了）。从结点A得到信息，修改后再发回给A，这就是产生混乱的根源。所以，结点B在发送路由表给A之前要删除路由表中下一跳为A的路由信息。在这种情况下，结点A保留到X的距离为无穷大。在此之后，当结点A将其路由表发送给B时，结点B也就更正了它的路由表。系统在第一次更新后就变稳定了，因为结点A和B都知道了X是不可达的。 3) 分割范围和毒性逆转：使用分割范围策略有一个缺点。通常，距离向量协议使用一个计时器，若长时间没有关于某个路由的消息，就要从路由表中删除这个路由。在前面描述的场景中，当结点B在它给A的通告中删除了到X的路由时，结点A并不能猜出这是由于分割范围策略(因为信息的来源是A)，还是因为B最近一直都没有收到有关X的任何消息。分割范围策略可以与毒性逆转（poison reverse）策略组合起来使用。结点B可以仍然通知关于X的数值，但如果信息源是A，就把距离换成为无穷大(16)作为一种警告：“不要使用这个数值，我所知道的关于这条路由的信息来自于你。” 三结点不稳定性​ 分割范围和毒性逆转可以用于避免二结点的不稳定性，但如果是三个结点之间，稳定性仍然无法保证。","permalink":"http://Charles-xcz.github.io/2019/11/06/路径向量路由选择/","photos":[]}]}