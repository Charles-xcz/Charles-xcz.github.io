{"meta":{"title":"Charles","subtitle":null,"description":null,"author":"Charles","url":"http://Charles-xcz.github.io","root":"/"},"posts":[{"tags":[{"name":"JVM","slug":"JVM","permalink":"http://Charles-xcz.github.io/tags/JVM/"}],"title":"","date":"2020/02/29","text":"JVM学习——类加载、连接与初始化 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的 提供了更大的灵活性，增加了更多的可能性 1. Java虚拟机与程序的生命周期 如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 2. 加载​ 查找并加载类的二进制数据，就是将二进制形式的Java类型读入Java虚拟机中。 ​ 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 3. 连接​ 类被加载后，就进入连接阶段。分为验证，准备，解析三个阶段 ​ 连接就是将已经读到内存中的类的二进制数据合并到虚拟机的运行环境中去。 ​ 验证：确保被加载类的正确性 ​ 类验证的内容 类文件的结构检查 语义检查 字节码验证 二进制兼容性的验证 ​ 准备：Java虚拟机为类的静态变量分配内存，并将其初始化为默认值 ​ 解析：把类中的符号引用（间接）转换为直接引用 4. 初始化​ 为类的静态变量赋予正确的初始值 ​ 静态变量的声明语句，以及静态代码块都被看做类的初始化语句。 ​ Java虚拟机会按照初始化语句在类文件中的先后顺序依次执行它们。 ​ 类初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 假如类中存在初始化语句，那就依次执行这些初始化语句 ​ 类初始化的时机 ​ Java对类的使用方式可分为两种 主动使用 被动使用 ​ 所有的Java虚拟机实现必须要在每个类或接口被Java程序”首次主动使用“时才初始化它们 ​ 主动使用（七种，重要） 创建类的实例（new一个实例） 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.test.Test”)） 初始化该类的子类 Java虚拟机启动时被标明为启动类的类（包含main（）方法的类） JDK1.7开始提供的动态语言支持 ​ 除了上述七种情况，其他情况都认为是对类的被动使用，因此都不会导致类的初始化 ​ 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但这条规则不适用于接口。 在初始化一个类时，并不会先初始化它所实现的接口 在初始化一个接口时，并不会先初始化它的父接口 ​ 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 ​ 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使 5. 类的实例化 为新的对象分配内存 为实例变量赋默认值 为实例变量赋正确的初始值 Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为“”。针对源代码中每一个类的构造方法，Java编译器都产生一个方法。 Some Cases/** * 类的初始化 * 虚拟机参数 -XX:+&lt;option&gt; 表示开启 &lt;option&gt; 选项 * -XX:-&lt;option&gt; 表示关闭 &lt;option&gt; 选项 * -XX:&lt;option&gt;=&lt;value&gt; 表示给 &lt;option&gt; 选项赋值 * -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来 * -XX:+TraceClassUnLoading 用于追踪类的卸载信息并打印出来 * * @author charles * @date 2020/2/19 10:40 */ public class MyTest1 &#123; public static void main(String[] args) &#123; /* 对于静态字段来说,只有直接定义了该字段的类才会被初始化 str是在MyParent1中被定义,所以 MyChild1.str是对类 MyParent1 的主动使用, 所以类 MyParent1 会被初始化 */ System.out.println(MyChild1.str); /* str2 是在 MyChild1 中被定义,所以类 MyChild1 会被初始化 初始化一个类的子类时,父类也会被初始化(主动使用) */ System.out.println(MyChild1.str2); &#125; &#125; class MyParent1 &#123; public static String str = \"hello world\"; static &#123; System.out.println(\"MyParent1 static block\"); &#125; &#125; class MyChild1 extends MyParent1 &#123; public static String str2 = \"welcome\"; static &#123; System.out.println(\"MyChild1 static block\"); &#125; &#125; /** * 定义常量的类的初始化: * 常量在编译阶段会存入到调用这个常量的方法的类的常量池中, * 本质上调用类并没有直接引用到定义常量的类,因此并不会触发定义常量类的初始化 * 反编译 javap -c com.charles.jvm.classloader.MyTest2 * 助记符: * ldc:表示将int,float或是String类型的常量值从常量池中推送至栈顶 * bipush:表示将单字节(-128~127)的常量值从常量池中推送至栈顶 * sipush:表示将短整型(-32768~32767)的常量值从常量池中推送至栈顶 * iconst_i:i属于(-1~5)表示将int型的数字i从常量池中推送至栈顶 * * @author charles * @date 2020/2/19 11:21 */ public class MyTest2 &#123; public static void main(String[] args) &#123; /* 这里常量 MyParent2.STR 存放到了类 MyTest2 的常量池中, 之后 MyTest2 与 MyParent2 就没有任何关联了 甚至,我们可以将 MyParent2 的class文件删除 */ System.out.println(MyParent2.STR); &#125; &#125; class MyParent2 &#123; public static final String STR = \"hello world\"; static &#123; System.out.println(\"MyParent2 static block!\"); &#125; &#125; //反编译结果如下 D:\\Develop\\Java\\JavaProject\\JVMStudy\\build\\classes\\java\\main&gt;javap -c com.charles.jvm.classloader.MyTest2 Compiled from \"MyTest2.java\" public class com.charles.jvm.classloader.MyTest2 &#123; public com.charles.jvm.classloader.MyTest2(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello world 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return &#125; /** * 当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中 * 这时在程序运行时,会导致主动使用这个常量所在类,显然会导致这个类被初始化 * * @author charles * @date 2020/2/20 10:24 */ public class MyTest3 &#123; public static void main(String[] args) &#123; System.out.println(MyParent3.STRING); &#125; &#125; class MyParent3 &#123; public static final String STRING = UUID.randomUUID().toString(); static &#123; System.out.println(\"MyParent3 static block\"); &#125; &#125; /** * 创建类的实例,主动使用 * 对于数组实例来说,其类型是由JVM在运行期间动态生成的, * 表示为[Lcom.charles.jvm.classloader.MyParent4这种形式 * 动态生成的类型其父类就是Object * 对于数组来说,JavaDoc经常将构成数组的元素为Component,实际上就是将数组降低一个维度后的类型 * 助记符: * anewarray:表示创建一个引用类型的数组,并将其引用值压入栈顶 * newarray:表示创建一个指定的原始类型的数组,并将其引用值压入栈顶 * * @author charles * @date 2020/2/20 10:33 */ public class MyTest4 &#123; public static void main(String[] args) &#123; /* 首次主动使用才会初始化 */ MyParent4 p1 = new MyParent4(); MyParent4 p2 = new MyParent4(); /* 类的数组的实例,不是对类的主动使用 */ MyParent4[] parent4s = new MyParent4[2]; &#125; &#125; class MyParent4 &#123; static &#123; System.out.println(\"MyParent4 static block\"); &#125; &#125; /** * 当一个接口在初始化时,并不都要求其父接口完成初始化 * 只有当真正使用到父接口的时候(如引用到接中的常量时),才会初始化 * * @author charles * @date 2020/2/20 11:00 */ public class MyTest5 &#123; public static void main(String[] args) &#123; System.out.println(MyChild5.B); &#125; &#125; interface MyParent5 &#123; /** * 接口中的属性,默认为public static final */ int A = 5; &#125; interface MyChild5 extends MyParent5 &#123; int B = new Random().nextInt(); &#125; /** * @author charles * @date 2020/2/20 11:31 */ public class MyTest6 &#123; public static void main(String[] args) &#123; /* 调用了类Singleton中的静态方法,为主动使用,类Singleton被初始化 */ Singleton singleton = Singleton.getInstance(); System.out.println(\"counter1:\" + Singleton.counter1); System.out.println(\"counter2:\" + Singleton.counter2); &#125; &#125; class Singleton &#123; /** * 初始化counter1为1 */ public static int counter1 = 1; /** * 按顺序进行初始化,构造函数执行后,counter1=4,counter2=3 */ private static Singleton singleton = new Singleton(); /** * 然后counter2又被赋值为0 */ public static int counter2 = 8; private Singleton() &#123; /* counter1在前面已经被初始化为1,所以counter1=1+3 */ counter1 += 3; /* 准备阶段的意义 因为准备阶段,整型的默认值为0 所以counter2=0+3 */ counter2 += 3; &#125; public static Singleton getInstance() &#123; return singleton; &#125; &#125;","permalink":"http://Charles-xcz.github.io/2020/02/29/JVM学习——类加载、连接与初始化/","photos":[]},{"tags":[],"title":"","date":"2019/11/06","text":"距离向量路由选择​ 距离向量路由选择是通过对Bellman-Ford算法进行适当修改，找到任意两结点之间的最短路径。 ​ 先介绍一下Bellman-Ford算法： 1 Bellman-Ford算法​ 这个算法基于这样一个事实，如果结点 i 的所有邻站都知道到结点的最短距离，那么求结点 i 和结点 j 之间的最短距离就可以用结点 i 到每个邻站之间的距离分别加上该邻站到结点j的最短距离，然后再从得数中选择最小的一个。 用以下步骤为每个结点创建一个最短距离表 : 1) 结点和它自己之间的最短距离和代价被初始化为0。 2) 一个结点和任何其他结点之间的最短距离被设置为无穷大。一个结点和其他任何结点之间的代价应当给定(如果两个节点之间没有直接连接，可设置为无穷大)。 3) 然后循环执行 算法Dij = min{(ci1+D1j),(ci2+D2j),……..(ciN+DNj)} 2 距离向量路由选择算法1) 在距离向量路由选择中，代价通常就是跳数（即在到达终点之前通过了多少个网络）。因此任意两个邻站之间的代价被设置为1。 2) 每当路由器从它的邻站那里接收到一些信息时，它就要异步地更新自己的路由表。换言之，每个路由器只执行了整个Bellman-Ford算法中的一部分。这个处理过程是分布式的。 3) 在路由器更新了自己的路由表之后，应当将结果发送给它的所有邻站，以便这些邻站也能更新它们的路由表。 4) 每个路由器至少应当保存每条路由的三个信息：目的网络、代价和下一跳。我们称完整的路由表为Table，表中的第i行为Tablei第i行的三个列分别为Tablei.dest，Tablei.cost和Tablei.next。 5) 我们把来自邻站的一条路由信息称为一个R（记录），它只包含了两个信息：R.dest和R.cost。在收到的记录中不包含下一跳信息，因为下一跳就是发送方的源地址。 3 计数到无穷大​ 距离向量路由的缺点是：好消息传得快，坏消息传得慢。要想让路由选择协议能够正常工作，如果一条链路中断了（代价变为无穷大），那么其他所有路由器都应当立刻获知这一情况，但是在距离向量路由选择中，这是要花费一些时间的。这个问题就称为计数到无穷大（count to infinity）。需要经过多次更新才能使所有的路由器都把这条中断链路的代价记录为无穷大。 二结点循环问题: 为了解决这种不稳定性的几种方法： 1) 定义无穷大：距离向量协议一般把16定义为无穷大，即16跳为不可达，但是这也意味着距离向量不能用于大系统。在各个方向上，网络的大小都不能超过15跳。 2) 分割范围：如果结点B根据其路由表认为到达X的最佳路由要经过A，那么它就不需要再把到X的路由通告给A了，因为这个信息就是从A来的（A已经知道了）。从结点A得到信息，修改后再发回给A，这就是产生混乱的根源。所以，结点B在发送路由表给A之前要删除路由表中下一跳为A的路由信息。在这种情况下，结点A保留到X的距离为无穷大。在此之后，当结点A将其路由表发送给B时，结点B也就更正了它的路由表。系统在第一次更新后就变稳定了，因为结点A和B都知道了X是不可达的。 3) 分割范围和毒性逆转：使用分割范围策略有一个缺点。通常，距离向量协议使用一个计时器，若长时间没有关于某个路由的消息，就要从路由表中删除这个路由。在前面描述的场景中，当结点B在它给A的通告中删除了到X的路由时，结点A并不能猜出这是由于分割范围策略(因为信息的来源是A)，还是因为B最近一直都没有收到有关X的任何消息。分割范围策略可以与毒性逆转（poison reverse）策略组合起来使用。结点B可以仍然通知关于X的数值，但如果信息源是A，就把距离换成为无穷大(16)作为一种警告：“不要使用这个数值，我所知道的关于这条路由的信息来自于你。” 三结点不稳定性​ 分割范围和毒性逆转可以用于避免二结点的不稳定性，但如果是三个结点之间，稳定性仍然无法保证。","permalink":"http://Charles-xcz.github.io/2019/11/06/路径向量路由选择/","photos":[]}]}