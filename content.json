{"meta":{"title":"Charles","subtitle":null,"description":null,"author":"Charles","url":"http://Charles-xcz.github.io","root":"/"},"posts":[{"tags":[{"name":"多线程","slug":"多线程","permalink":"http://Charles-xcz.github.io/tags/多线程/"},{"name":"volatile","slug":"volatile","permalink":"http://Charles-xcz.github.io/tags/volatile/"}],"title":"并发编程之——volatile","date":"2020/02/29","text":"1. volatile特征 volatile是Java虚拟机提供的轻量级同步机制 1. 保证可见性 某一线程修改了一个变量值并写回主内存后，会马上通知其它使用该变量的线程进行修改 2. 不保证原子性3. 禁止指令重排volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。 先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个： 保证特定操作的执行顺序 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性） ​ 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。 ​ 内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。（保证可见性） ​ 对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存中。 ​ 对volatile变量进行读操作时，会在读操作后加入一条load屏障指令，从主内存中读取共享变量。 想要了解volatile特性的具体含义，我们先来了解一下JMM。 2. JMM​ JMM（Java内存模型 Java Memory Model，简称JMM）本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 ​ JMM关于同步的规定： 线程解锁前，必须把共享变量的值刷新回主内存 线程加锁前，必须读取主内存的最新值到自己的工作内存 加锁解锁是同一把锁 ​ 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域。 ​ 而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行。 ​ 线程操作变量时，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存。 ​ 因此，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图： JMM的三大特性 可见性 通过前面对JMM的介绍，我们知道 各个线程对主内存中共享变量的操作都是各个线程拷贝到自己的工作内存进行操作后再写回到主内存中的。 这就可能存在一个线程A修改了共享变量x的值但还未写回主内存时，另外一个线程B又对主内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就叫作可见性问题 。 原子性 不可分割性，完整性，也即某个线程正在做着某个具体的业务时，中间不可以被加塞或者被分割。需要整体完整，要么同时成功要么同时失败。 volatile不能保证原子性 如何解决原子性问题？ ​ 加synchronized锁 ​ 使用juc下的原子类，例如AtomicInteger原子整型 有序性 计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种 ​ 指令重排，在单线程环境里，要能确保程序最终执行结果和代码顺序执行的结果是一致的。 ​ 处理器在进行重排序时必须要考虑指令之间的数据依赖性 ​ 但是在多线程环境中，线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。 3. 程序示例seek() 方法， number不加volatile修饰时，会在while(myData.number == 0)处死循环 加volatile修饰，程序正常执行，证明了volatile的可见性：当某一线程修改了一个变量值并写回主内存后，会马上通知其它使用该变量的线程进行修改。 atomic() 方法， 加了volatile的情况下，number的输出结果依然小于20000，这就是不能保证原子性 atomicInteger结果为2000，AtomicInteger保证原子性 class MyData &#123; //int number = 0; volatile int number = 0; public void addTo60() &#123; this.number = 60; &#125; public void addPlusPlus() &#123; this.number++; &#125; AtomicInteger atomicInteger = new AtomicInteger(); public void addAtomic() &#123; atomicInteger.getAndIncrement(); &#125; &#125; public class VolatileDemo01 &#123; /** *验证可见性方法 */ public void seek() &#123; MyData myData = new MyData(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \":come in\"); //加休息1s,为了确保main线程进入循环时number为0 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; myData.addTo60(); System.out.println(Thread.currentThread().getName() + \":update number to \" + myData.number); &#125;, \"AAA\").start(); while (myData.number == 0) &#123; &#125; System.out.println(Thread.currentThread().getName() + \"is over\"); &#125; /** *验证原子性方法 */ public void atomic() &#123; MyData myData=new MyData(); for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt;&#123; for (int j = 0; j &lt; 1000; j++) &#123; myData.addPlusPlus(); myData.addAtomic(); &#125; &#125;,String.valueOf(i)).start(); &#125; //需要等待上面20个线性计算完成后,再用main线程取得最终结果,看看是多少 //因为默认有两个线程,main线程和后台gc线程 while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+\"finally number value:\"+myData.number); System.out.println(Thread.currentThread().getName()+\"finally atomicInteger value:\"+myData.atomicInteger); &#125; &#125; 3. 禁止指令重排作用场景​ 单例模式DCL DCL（Double Check Lock）机制不一定100%线程安全，原因是指令重排序的存在，加入volatile可以禁止指令重排序 ​ 原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。 ​ instance=new SingletonDemo()；可以分为以下3步完成（伪代码） memory = allocate(); //1.分配对象内存空间 instance(memory); //2.初始化对象 instance = memory; //3.设置instance指向刚分配的内存地址，此时instance！=null ​ 由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。 memory=allocate(); //1.分配对象内存空间 instance=memory(); //3.设置instance指向刚分配的内存地址，此时instance!=null，但是对象还没有初始化完成！ instance(memory); //2.初始化对象 ​ 但是指令重排只会保证串行语义的执行的一致性（单线程），但并不会关心多线程间的语义一致性。 ​ 所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。 关于AtomicInteger类如何保证原子性，参看CAS的原理。","permalink":"http://Charles-xcz.github.io/2020/02/29/并发编程之-volatile/","photos":[]},{"tags":[{"name":"红黑树","slug":"红黑树","permalink":"http://Charles-xcz.github.io/tags/红黑树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://Charles-xcz.github.io/tags/数据结构/"}],"title":"什么是红黑树？","date":"2020/02/29","text":"1. 定义红黑树是满足下列条件的二叉查找树： 每个节点都带有红色或黑色。节点的颜色由以下规则确定： 根节点是黑色的。 所有叶节点都是黑色的。 在沿着从根出发的任何路径上都不允许出现两个连续的红色节点，即：“红色”结点的两个子结点都是“黑色”的。 从任一节点到其每个子孙叶子节点的所有简单路径都包含相同数目的黑色节点（简称黑色高度） 节点X的黑色高度：从节点X到其子孙叶子节点的简单路径中的黑色链的数量。 红黑树的黑色高度：根节点的黑色高度（称为：根节点的阶）红黑树的两种不同定义： 《算法导论》：叶子节点是指，扩充外部叶结点。即叶子节点为空的“黑色”节点 - 可以认为是2-3-4树的二叉树实现 《程序员实用算法》：数据只存储在叶子节点中，内部节点只用于引用； 示例: 《算法导论》中的红黑树,，黑色高度为2。 《程序员实用算法》中的红黑树，黑色高度为2。加粗为黑色结点本文基于《算法导论》的定义介绍。 2. 红黑树 与 2-3-4树红黑树，可等价转化为2-3-4树。 为了更好的理解红黑树，先看一下2-3-4树 2.1 2-3-4树介绍2-3-4树： 2-3-4树： 是二叉查找树的扩展 树中每个节点中有1个或2个或3个关键字，节点内部是有序的。 2-节点：有1个关键字，2个孩子 3-节点：有2个关键字，3个孩子 4-节点：有3个关键字，4个孩子 具有很好的平衡性：所有叶子节点的深度相同。 2-3-4树的查找插入B结点插入结点H 注意：在插入结点过程中，按照自顶向下的方式进行访问，当发现4-节点时，进行分裂。 即：插入结点时在遍历查找插入位置的路线上，凡是遇到4-结点，就对其进行分裂 现在，自顶向下构造一棵2-3-4树 2.2 二叉树来实现2-3-4树2-3-4树中有三类节点： 2-节点，3-节点和4-节点 对于3-节点和4-节点，利用红色链来绑定“内部”节点 红色链所指向的节点为红色节点（红色链下方的结点） 2-节点不变 3-节点变为用红色链连接的两个二叉树节点，指向外部孩子节点的指针为3个，数量不变。 4-节点转化为三个用红色链连接起来的二叉树节点，指向外部孩子节点的指针为4个，数量不变。 这样，2-3-4树就转化成了二叉树。但是，可以看到，2-3-4树对应的二叉树并不唯一，哪种才是等价的红黑树呢？ 2-3-4树的2-节点和4-节点变成成二叉树节点都是唯一的情况，3-节点呢？我们人为的规定，转换成左分支的情况，（左孩子节点小于父节点，二叉查找树的性质）并且在插入新节点的过程中，产生右分支的时候我们需要把它左旋成为左分支情况。这样，2-3-4树就对应成了唯一的二叉树，即红黑树。（红色链连接代表着2-3-4树节点内部的连接，红色链下方的节点表示红色节点） 那么，现在还剩下一个问题，2-3-4树插入节点过程中的4-节点分裂，对应着二叉树怎样的变化呢？ 2-3-4树中，双亲为2-节点时，4-节点的分裂： 2-3-4树4-节点分裂对应着二叉树的颜色向上翻转，当翻转后出现，右分支情况的3-节点时，旋转成左分支情况2-3-4树中，双亲为3-节点时，4-节点的分裂：在对应二叉树中，同样可以用颜色翻转和旋转等价实现。 当反转后，出现两个红色节点连续，显然不满足红黑树的定义，要进行旋转，旋转规则类似与AVL树失衡的旋转处理。 下面的两个旋转情况，和AVL树LL失衡，LR失衡旋转情况相同 3.总结：红黑树，本质上是2-3-4树两类基本操作： 颜色翻转 实质上为4-节点分裂 当某个结点的两个孩子结点都为红色时 将两个红色孩子结点和其黑色双亲结点的颜色翻转旋转 避免出现连续的两条红色链；避免出现单个的红色右链。 出现右的红色链时：对于右的红色链，进行左旋处理 有连续两个红色链时： 依据两个连续的红色链的形状，进行相应的旋转处理（类似AVL树的失衡旋转规则） 看道小试题， 从空树出发，根据待插入的关键字序列 {03,02,01,04,05,06,07,10,09,08}.构建红黑树。 仔细体会一下红黑树的构建过程。 可以画出对应2-3-4树的插入构建过程和红黑树对比加深理解。（节点依次插入，树未发生翻转变化时省略了重复画图）注意：将红色链指向(下方)的节点定义为红色节点，不要迷惑于红色节点的变化","permalink":"http://Charles-xcz.github.io/2020/02/29/聊聊红黑树/","photos":[]},{"tags":[{"name":"JVM","slug":"JVM","permalink":"http://Charles-xcz.github.io/tags/JVM/"}],"title":"JVM学习(1)——类加载、连接与初始化","date":"2020/02/29","text":"在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。这提供了更大的灵活性，增加了更多的可能性 1. Java虚拟机与程序的生命周期 如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 2. 加载​ 查找并加载类的二进制数据，就是将二进制形式的Java类型读入Java虚拟机中。 ​ 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内。然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 3. 连接​ 类被加载后，就进入连接阶段。分为验证，准备，解析三个阶段 ​ 连接就是将已经读到内存中的类的二进制数据合并到虚拟机的运行环境中去。 ​ 验证：确保被加载类的正确性 ​ 类验证的内容 类文件的结构检查 语义检查 字节码验证 二进制兼容性的验证 ​ 准备：Java虚拟机为类的静态变量分配内存，并将其初始化为默认值 ​ 解析：把类中的符号引用（间接）转换为直接引用 4. 初始化​ 为类的静态变量赋予正确的初始值 ​ 静态变量的声明语句，以及静态代码块都被看做类的初始化语句。 ​ Java虚拟机会按照初始化语句在类文件中的先后顺序依次执行它们。 ​ 类初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 假如类中存在初始化语句，那就依次执行这些初始化语句 ​ 类初始化的时机 ​ Java对类的使用方式可分为两种 主动使用 被动使用 ​ 所有的Java虚拟机实现必须要在每个类或接口被Java程序”首次主动使用“时才初始化它们 ​ 主动使用（七种，重要） 创建类的实例（new一个实例） 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.test.Test”)） 初始化该类的子类 Java虚拟机启动时被标明为启动类的类（包含main（）方法的类） JDK1.7开始提供的动态语言支持 ​ 除了上述七种情况，其他情况都认为是对类的被动使用，因此都不会导致类的初始化 ​ 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但这条规则不适用于接口。 在初始化一个类时，并不会先初始化它所实现的接口 在初始化一个接口时，并不会先初始化它的父接口 ​ 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 ​ 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使 5. 类的实例化 为新的对象分配内存 为实例变量赋默认值 为实例变量赋正确的初始值 Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为“”。针对源代码中每一个类的构造方法，Java编译器都产生一个方法。 Some Cases/** * 类的初始化 * 虚拟机参数 -XX:+&lt;option&gt; 表示开启 &lt;option&gt; 选项 * -XX:-&lt;option&gt; 表示关闭 &lt;option&gt; 选项 * -XX:&lt;option&gt;=&lt;value&gt; 表示给 &lt;option&gt; 选项赋值 * -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来 * -XX:+TraceClassUnLoading 用于追踪类的卸载信息并打印出来 * * @author charles * @date 2020/2/19 10:40 */ public class MyTest1 &#123; public static void main(String[] args) &#123; /* 对于静态字段来说,只有直接定义了该字段的类才会被初始化 str是在MyParent1中被定义,所以 MyChild1.str是对类 MyParent1 的主动使用, 所以类 MyParent1 会被初始化 */ System.out.println(MyChild1.str); /* str2 是在 MyChild1 中被定义,所以类 MyChild1 会被初始化 初始化一个类的子类时,父类也会被初始化(主动使用) */ System.out.println(MyChild1.str2); &#125; &#125; class MyParent1 &#123; public static String str = \"hello world\"; static &#123; System.out.println(\"MyParent1 static block\"); &#125; &#125; class MyChild1 extends MyParent1 &#123; public static String str2 = \"welcome\"; static &#123; System.out.println(\"MyChild1 static block\"); &#125; &#125; /** * 定义常量的类的初始化: * 常量在编译阶段会存入到调用这个常量的方法的类的常量池中, * 本质上调用类并没有直接引用到定义常量的类,因此并不会触发定义常量类的初始化 * 反编译 javap -c com.charles.jvm.classloader.MyTest2 * 助记符: * ldc:表示将int,float或是String类型的常量值从常量池中推送至栈顶 * bipush:表示将单字节(-128~127)的常量值从常量池中推送至栈顶 * sipush:表示将短整型(-32768~32767)的常量值从常量池中推送至栈顶 * iconst_i:i属于(-1~5)表示将int型的数字i从常量池中推送至栈顶 * * @author charles * @date 2020/2/19 11:21 */ public class MyTest2 &#123; public static void main(String[] args) &#123; /* 这里常量 MyParent2.STR 存放到了类 MyTest2 的常量池中, 之后 MyTest2 与 MyParent2 就没有任何关联了 甚至,我们可以将 MyParent2 的class文件删除 */ System.out.println(MyParent2.STR); &#125; &#125; class MyParent2 &#123; public static final String STR = \"hello world\"; static &#123; System.out.println(\"MyParent2 static block!\"); &#125; &#125; //反编译结果如下 D:\\Develop\\Java\\JavaProject\\JVMStudy\\build\\classes\\java\\main&gt;javap -c com.charles.jvm.classloader.MyTest2 Compiled from \"MyTest2.java\" public class com.charles.jvm.classloader.MyTest2 &#123; public com.charles.jvm.classloader.MyTest2(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello world 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return &#125; /** * 当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中 * 这时在程序运行时,会导致主动使用这个常量所在类,显然会导致这个类被初始化 * * @author charles * @date 2020/2/20 10:24 */ public class MyTest3 &#123; public static void main(String[] args) &#123; System.out.println(MyParent3.STRING); &#125; &#125; class MyParent3 &#123; public static final String STRING = UUID.randomUUID().toString(); static &#123; System.out.println(\"MyParent3 static block\"); &#125; &#125; /** * 创建类的实例,主动使用 * 对于数组实例来说,其类型是由JVM在运行期间动态生成的, * 表示为[Lcom.charles.jvm.classloader.MyParent4这种形式 * 动态生成的类型其父类就是Object * 对于数组来说,JavaDoc经常将构成数组的元素为Component,实际上就是将数组降低一个维度后的类型 * 助记符: * anewarray:表示创建一个引用类型的数组,并将其引用值压入栈顶 * newarray:表示创建一个指定的原始类型的数组,并将其引用值压入栈顶 * * @author charles * @date 2020/2/20 10:33 */ public class MyTest4 &#123; public static void main(String[] args) &#123; /* 首次主动使用才会初始化 */ MyParent4 p1 = new MyParent4(); MyParent4 p2 = new MyParent4(); /* 类的数组的实例,不是对类的主动使用 */ MyParent4[] parent4s = new MyParent4[2]; &#125; &#125; class MyParent4 &#123; static &#123; System.out.println(\"MyParent4 static block\"); &#125; &#125; /** * 当一个接口在初始化时,并不都要求其父接口完成初始化 * 只有当真正使用到父接口的时候(如引用到接中的常量时),才会初始化 * * @author charles * @date 2020/2/20 11:00 */ public class MyTest5 &#123; public static void main(String[] args) &#123; System.out.println(MyChild5.B); &#125; &#125; interface MyParent5 &#123; /** * 接口中的属性,默认为public static final */ int A = 5; &#125; interface MyChild5 extends MyParent5 &#123; int B = new Random().nextInt(); &#125; /** * @author charles * @date 2020/2/20 11:31 */ public class MyTest6 &#123; public static void main(String[] args) &#123; /* 调用了类Singleton中的静态方法,为主动使用,类Singleton被初始化 */ Singleton singleton = Singleton.getInstance(); System.out.println(\"counter1:\" + Singleton.counter1); System.out.println(\"counter2:\" + Singleton.counter2); &#125; &#125; class Singleton &#123; /** * 初始化counter1为1 */ public static int counter1 = 1; /** * 按顺序进行初始化,构造函数执行后,counter1=4,counter2=3 */ private static Singleton singleton = new Singleton(); /** * 然后counter2又被赋值为0 */ public static int counter2 = 8; private Singleton() &#123; /* counter1在前面已经被初始化为1,所以counter1=1+3 */ counter1 += 3; /* 准备阶段的意义 因为准备阶段,整型的默认值为0 所以counter2=0+3 */ counter2 += 3; &#125; public static Singleton getInstance() &#123; return singleton; &#125; &#125;","permalink":"http://Charles-xcz.github.io/2020/02/29/JVM学习(1)——类加载、连接与初始化/","photos":[]},{"tags":[{"name":"网络","slug":"网络","permalink":"http://Charles-xcz.github.io/tags/网络/"}],"title":"距离向量路由选择","date":"2019/11/06","text":"​ 距离向量路由选择是通过对Bellman-Ford算法进行适当修改，找到任意两结点之间的最短路径。 ​ 先介绍一下Bellman-Ford算法： 1 Bellman-Ford算法​ 这个算法基于这样一个事实，如果结点 i 的所有邻站都知道到结点的最短距离，那么求结点 i 和结点 j 之间的最短距离就可以用结点 i 到每个邻站之间的距离分别加上该邻站到结点j的最短距离，然后再从得数中选择最小的一个。 用以下步骤为每个结点创建一个最短距离表 : 1) 结点和它自己之间的最短距离和代价被初始化为0。 2) 一个结点和任何其他结点之间的最短距离被设置为无穷大。一个结点和其他任何结点之间的代价应当给定(如果两个节点之间没有直接连接，可设置为无穷大)。 3) 然后循环执行 算法Dij = min{(ci1+D1j),(ci2+D2j),……..(ciN+DNj)} 2 距离向量路由选择算法1) 在距离向量路由选择中，代价通常就是跳数（即在到达终点之前通过了多少个网络）。因此任意两个邻站之间的代价被设置为1。 2) 每当路由器从它的邻站那里接收到一些信息时，它就要异步地更新自己的路由表。换言之，每个路由器只执行了整个Bellman-Ford算法中的一部分。这个处理过程是分布式的。 3) 在路由器更新了自己的路由表之后，应当将结果发送给它的所有邻站，以便这些邻站也能更新它们的路由表。 4) 每个路由器至少应当保存每条路由的三个信息：目的网络、代价和下一跳。我们称完整的路由表为Table，表中的第i行为Tablei第i行的三个列分别为Tablei.dest，Tablei.cost和Tablei.next。 5) 我们把来自邻站的一条路由信息称为一个R（记录），它只包含了两个信息：R.dest和R.cost。在收到的记录中不包含下一跳信息，因为下一跳就是发送方的源地址。 3 计数到无穷大​ 距离向量路由的缺点是：好消息传得快，坏消息传得慢。要想让路由选择协议能够正常工作，如果一条链路中断了（代价变为无穷大），那么其他所有路由器都应当立刻获知这一情况，但是在距离向量路由选择中，这是要花费一些时间的。这个问题就称为计数到无穷大（count to infinity）。需要经过多次更新才能使所有的路由器都把这条中断链路的代价记录为无穷大。 二结点循环问题: 为了解决这种不稳定性的几种方法： 1) 定义无穷大：距离向量协议一般把16定义为无穷大，即16跳为不可达，但是这也意味着距离向量不能用于大系统。在各个方向上，网络的大小都不能超过15跳。 2) 分割范围：如果结点B根据其路由表认为到达X的最佳路由要经过A，那么它就不需要再把到X的路由通告给A了，因为这个信息就是从A来的（A已经知道了）。从结点A得到信息，修改后再发回给A，这就是产生混乱的根源。所以，结点B在发送路由表给A之前要删除路由表中下一跳为A的路由信息。在这种情况下，结点A保留到X的距离为无穷大。在此之后，当结点A将其路由表发送给B时，结点B也就更正了它的路由表。系统在第一次更新后就变稳定了，因为结点A和B都知道了X是不可达的。 3) 分割范围和毒性逆转：使用分割范围策略有一个缺点。通常，距离向量协议使用一个计时器，若长时间没有关于某个路由的消息，就要从路由表中删除这个路由。在前面描述的场景中，当结点B在它给A的通告中删除了到X的路由时，结点A并不能猜出这是由于分割范围策略(因为信息的来源是A)，还是因为B最近一直都没有收到有关X的任何消息。分割范围策略可以与毒性逆转（poison reverse）策略组合起来使用。结点B可以仍然通知关于X的数值，但如果信息源是A，就把距离换成为无穷大(16)作为一种警告：“不要使用这个数值，我所知道的关于这条路由的信息来自于你。” 三结点不稳定性​ 分割范围和毒性逆转可以用于避免二结点的不稳定性，但如果是三个结点之间，稳定性仍然无法保证。","permalink":"http://Charles-xcz.github.io/2019/11/06/路径向量路由选择/","photos":[]}]}